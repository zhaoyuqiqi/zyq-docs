# 动态规划

动态规划多用来完成递归操作的逆操作，在递归中，我们求解的问题都是一样的，只是在逐渐缩小问题的规模，最终求解出我们的问题。动态规划是根据前面我们已经求解出的问题来推导出后续我们需要求解的问题。

在 leetcode 中有如下经典题目：

## 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

示例 1：

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。

1. 1 阶 + 1 阶
2. 2 阶
   示例 2：

输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。

1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶

提示：

1 <= n <= 45

- 我们思路如下：
  - 首先我们声明一个 dp 数组用来存放我们的计算结果，其中数组 `dp[i]`代表的是在索引 `i` 这个位置也就是爬 `i + 1` 阶楼梯的方法数，首先对数组进行初始化，直接使用 0 填充即可（其实使用什么都无所谓）。然后对爬一阶楼梯和两阶楼梯进行初始化，爬一阶楼梯就是只有一种，爬两阶楼梯就是有两种（一阶一阶爬或是一次性爬两阶）。
  - 然后开启一个循环，我们的递推公式就是`dp[i] = dp[i - 1] + dp[i - 2]`，使用这个公式进行填充我们的 dp 数组即可，最后返回 dp 数组的最后一项即可。
- 代码实现如下：
  ```ts
  function climbStairs(n: number): number {
    const dp: number[] = new Array(n).fill(0);
    dp[0] = 1;
    dp[1] = 2;
    for (let i = 2; i < n; i++) {
      dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n - 1];
  }
  ```

## 最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：

输入：nums = [0,1,0,3,2,3]
输出：4
示例 3：

输入：nums = [7,7,7,7,7,7,7]
输出：1

提示：

1 <= nums.length <= 2500
-10^4 <= nums[i] <= 10^4

- 我们的思路如下：
  - 首先创建一个 dp 数组，明确我们 dp 数组中`dp[i]`的含义，它代表当前`i`位置的上最长递增子序列是多少。
  - 我们创建一个长度与原数组长度相同的 dp 数组，然后填充 1（我们假设当前位置只有它自己是单调递增的）来将其初始化。
  - 然后开启两层嵌套 for 循环，第一层为当前的位置的值，第二次循环为开头到当前位置。我们表第一层循环的值和第二层循环的值，倘若当前位置的值大于内层循环的值那么我们就将 dp[i]替换为之前的 dp[i]和 dp[j] + 1 中较大的那个。
  - 最后返回 dp 数组中最大的那个即可。
- 代码实现如下：

  ```ts
  function lengthOfLIS(nums: number[]): number {
    const dp: number[] = new Array(nums.length).fill(1);
    for (let i = 0; i < nums.length; i++) {
      for (let j = 0; j < i; j++) {
        if (nums[i] > nums[j]) {
          dp[i] = Math.max(dp[i], dp[j] + 1);
        }
      }
    }
    return Math.max(...dp);
  }
  ```

该题目还有另一种使用贪心算法 + 二分算法的解法，在此不作赘述，放在 Vue 底层 diff 算法原理及实现中讲述。

## 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
偷窃到的最高金额 = 2 + 9 + 1 = 12 。

提示：

1 <= nums.length <= 100
0 <= nums[i] <= 400

- 我们的思路如下：
  - 题目说到不触发报警的情况下能偷到的最大金额是多少，因为我们偷任意两个连着的房子就会触发报警，所以我们只能隔一个偷，那我们要怎么做呢？
  - 首先，我们初始化一个 dp 数组，其中 dp[i]表示偷前 i-1 家能偷到的最大金额，我们使用默认值 0 来填充即可。
  - 然后，我们的递推公式中 dp[i] 的值就是 dp[i - 1] 与 di[i - 2] + 当前的金额中较大的那一个。
  - 最后，我们返回 dp 数组的最后一项即可。
- 代码如下：

  ```ts
  function rob(nums: number[]): number {
    const dp = new Array(nums.length).fill(0);
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    for (let i = 2; i < nums.length; i++) {
      dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    return dp[nums.length - 1];
  }
  ```

## 零钱兑换（硬币找零）
