# 杂七杂八

## 获取中间位置

- 使用除以二然后再取整的方法

  - 痛点一：最小值与最大值的和有可能超出数字的精度范围。
  - 痛点二：必须调用数学方法进行取整。

  ```ts
  const low = 0,
    high = 10;
  const mid = Math.floor((low + high) / 2);
  ```

- 使用位运算

  - 痛点一：最小值与最大值的和有可能超出数字的精度范围。
    - 原理是因为右移 1 位后，二进制数最后一位的精度丢失导致自动向下取整，解决了需要调用数学方法的痛点。

  ```ts
  const low = 0,
    high = 10;
  const mid = (low + high) >> 1;
  ```

- 使用位运算并解决 low + high 超出安全表示范围的场景。
  - 解决了上述的两个痛点，上述痛点二解决原理不再赘述，痛点一的解决思路是，既然 low 与 high 各自都没有超出精度范围，那么 high- low 必定没有超出精度范围，这个值的一半也是同理，使用 low + 这个值的一半必定不会大于 high，因此表示是安全的。
  ```ts
  const low = 0,
    high = 10;
  const mid = low + ((high - low) >> 1);
  ```

## 性能优化

### 图片格式与体积优化

- 在 web 中我们可以使用精灵图也叫雪碧图配合 css 的 background-position 进行背景定位，这样子可以在本来需要加载多张小图的场景只加载一张图，然后通过背景定位的方式定位到当前需要展示的图片位置进行展示。
  - 优点：减小 http 并发请求数量，加快了图片资源的展示。（由多张图下载完成才能全部展示变为只需要下载一张图即可）。
  - 缺点：修改精灵图中单个图的时候需要整体替换原来图片，如果新的图片位置大小有调整，整体的图片需要挨个调整位置，使其正常展示，不方便。
- 将图片进行压缩，推荐使用[tiny](https://tinify.cn/)网站进行图片压缩，可大大减小图片体积，加快图片加载速度。
- 优化图片格式：
  - 简单介绍下下列图片格式：
    - jpg，可以用来进行展示色彩丰富的图片，其中没有 alpha 通道，因此不能展示透明像素，透明像素会默认渲染为白色底，在没有透明像素的情况下使用该格式相比于其他格式可以减小图片体积，加快图片加载速度。
    - png，可以用来展示带有透明像素的图片，该格式即使在压缩后也不会导致任何文件质量的损失。支持图像透明度，并提供比 GIF 更好的质量。该格式具有 256 级不透明度，从完全不透明到完全透明不等；该格式适合于存储图像的即时版本，因为重新保存不会导致质量损失；该格式支持广泛的颜色范围；不适合全彩色图像的展示。
    - gif，多用来创建动图，支持 alpha 通道，可展示透明像素，图片体积比 png 较大。
    - webp，与 png 格式类似，但是其体积远小于 png 格式，缺点是浏览器支持性较差，尤其是在 ios13 以下，不支持 webp 格式展示。
  - 色彩丰富的图片使用 jpg 格式，相比于其他格式体积更小。
  - 有透明像素的图片使用 png 格式，如果对只需要支持新版现代浏览器可使用 webp 格式优化图片体积。
  - 动图可使用 gif 格式，gif 格式对动图的支持性以及浏览器的兼容性都相当不错。

### 图片预加载

- 在工作中我们可以使用图片预加载来对图片展示进行优化，利用加载后的缓存来减小后续图片加载时间。
- 我们可以在 web 中通过创建图片的方式`new Image()`，在使用图片之前预先对图片进行加载，加载后的图片会缓存在客户端，在需要用到该图片的位置展示时会直接读取缓存的图片，大大减小图片后续加载图片引起的页面闪烁与时间。
  - 使用场景举例：如 web 的游戏界面，开始前需要读 loading 的进度条，其实这个时候是在加载后续用到的图片，使后续加载时页面中的图片可以做到秒开，增强用户体验。
- 优点：
  - 大大减小后续图片上屏时加载态与完成态的转换过程对用户的可见度，增强了用户体验，但本质上还是需要加载全部图片，只是相当于把后续加载需要的时间进行了提前，可以使用并发来加快图片加载，如果用户浏览完全部图片页面总体时间会减小。我们可以在此使用一个进度条或是百分比 loading 对用户展示当前进度，提升用户体验。
- 缺点：
  - 还是需要对图片进行加载，本质上是对图片的加载时间进行了提前，如果用户没有浏览预加载图片页面还是需要付出全部预加载的时间；
  - 如果用户没有浏览完全部预加载页面，那么就增大了 http 图片请求量，白白浪费前面 http 的请求与用户时间。

### 图片懒加载

- 图片懒加载是在即将用到图片时候提前进行加载，不用一次性加载多个图片，可以理解为延迟加载。
- 与预加载的区别：预加载是提前进行某一场景全部图片的加载，避免用户看到后续图片上屏引起页面中图片的加载态与完成态的转换；懒加载是即将要对用户展示该图片时，再进行加载，如果用户用不到这个图片就不进行加载，一个是预先加载一个是延迟加载，懒加载多用在列表页，对列表页面中的图片进行懒加载。
- 优点：
  - 用在列表页，如果用户只浏览了一屏的图片那么就不需要对整个列表的图片进行加载，减小了 http 的并发流量。
- 缺点：
  - 因为延迟加载了图片，网络条件差的情形下有时用户会看到图片的加载态与完成态的转换，但一般在类似场景中都是可接受的。
- 实现方案：
  一般来说有两种实现方案如下：
  - 第一种是首先不将图片地址放置到图片元素的 `src` 属性，例如可以使用 `data-src` 属性来暂时存储图片的地址，然后监听列表页`container`的滚动事件（`scroll`,`wheel`,`mousewheel`,`resize`,`animationend`,`transitionend`,`touchmove`），然后使用元素的`getClientRects()`或`getBoundingClientRect()`方法来获取图片元素距离视口的位置，判断到达某个阈值后将`data-src`放置到图片的`src`属性上进行加载图片，以此来达到图片加载的效果。注意在加载完成后即可销毁该元素对于位置的监听。
  - 第二种方案是使用 web 的 新 api [intersectioObserver](https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API)来对图片元素进行位置监听，然后在进入屏幕或是某一个阈值进行对图片元素的`src`赋值。
  - 第一种方法兼容性更加优良，第二种方法实现起来更加简单，按需使用即可。

### 页面异步渲染大量数据

假设我们当前的页面有大量的数据进行上屏，比如有 10000 行表格内容，因为 js 是单线程的，如果我们一次性上屏的话页面会假死（卡住），无法响应用户事件，用户体验极差，但是我们又有如此多的数据需要上屏那么我们该怎么办呢？主要有以下两种方法：

- 使用定时器异步渲染 dom
  - 因为定时器是异步的宏任务，我们可以使用定时器异步进行页面渲染，这样就不会阻塞主线程对于用户事件的响应，可以提升用户体验。但是该方法有个缺点，如果用户的同步任务执行时间过长的话，那么定时器会一直延后进行执行，对于用户来说仍然会有页面卡顿无法响应用户事件的场景。
- 使用浏览器的 api [requestAnimationFrame](https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame)来进行异步渲染，该 api 是浏览器用来绘制动画的，执行频率随着浏览器的刷新频率变化，在高刷新率的屏幕上该方法会执行的更快，一般为 16.7ms 执行一次。在这个方法的回调中，我们可以对 dom 进行操作，以此达到异步更新的效果，该 api 在注册之后不会被用户的同步任务所阻塞，该 api 最低支持 IE10 兼容性也相当不错。

### 接口数据分批上屏

当我们使用 Vue 或是 React 时，虽然界面是已经是异步更新，但是如果在一次的`setState`中如果更新大量的 dom 节点那么对于浏览器来说页面的渲染压力还是比较大的，那么我们可以怎样优化呢？

- 在 React 的类组件中我们知道`setState`的第二个参数是一个 callback，这个 callback 在 dom 更新后会调用，所以我们可以将数据分批上屏渲染来降低页面的首屏渲染压力，加快首屏渲染速度。

- useEffect 会在每次渲染后都执行吗？ 是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。（我们稍后会谈到如何控制它。）你可能会更容易接受 effect 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。React 保证了每次运行 effect 的同时，DOM 都已经更新完毕，可以在钩子中进行更新。

  - hooks 副作用调用如下：

    ```ts
    useEffect(() => {
      // 这里会在dom更新结束之后调用
    }, [依赖]);
    ```

  📢：注意一定要有退出条件，避免无限递归调用。

- Vue 中的 watch 钩子也是一样的，如下：

  - 当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。如果想在侦听器回调中能访问被 Vue 更新之后的 DOM，你需要指明 flush: 'post' 选项：

  ```ts
  watch(source, callback, {
    flush: 'post',
  });
  watchEffect(callback, {
    flush: 'post',
  });
  ```

  - 后置刷新的 watchEffect() 有个更方便的别名 watchPostEffect()：

  ```ts
  import { watchPostEffect } from 'vue';

  watchPostEffect(() => {
    /_ 在 Vue组件 更新后执行 _/;
  });
  ```

  📢：注意一定要有退出条件，避免无限递归调用。

数据分批上屏也可以使用上文提到的`requestAnimationFrame`进行下一帧上屏，可以减小页面首屏首帧的渲染压力。

## 设置较小字号（小于 12px）的字体

web 中可设置的字体大小最小为 12px，无法设置小于 12px 的字体，目前大多数实现小字号的字体有以下常用两个方案

- 以我们需要设置 9px 的字体为例

### 使用 transform 缩放

```css
.ninepx-div {
  font-size: 12px;
  transform: scale(0.75);
  color: red;
}
```

我们可以设置字体大小为 12px 然后使用`transform:scale(0.75)`来让我们的元素进行缩放 3/4 以达到我们的 9px，但是该方案有个缺点就是元素的体积会塌陷，即盒子的大小会一起缩放，不会只缩放字体。

### 使用字体的 size-adjust 属性

```css
@font-face {
  font-family: ninepx;
  src: url('xxxx.ttf') format('truetype');
  size-adjust: 75%;
}
.ninepx-div {
  font-size: 12px;
  font-family: ninepx;
  color: red;
}
```

我们引入字体，然后设置 size-adjust 缩放比例，在我们需要缩放的文字上面我们可以使用该字体，然后设置相应的 12px 即可，因为缩放比例为 3/4 所以当我们设置 12px 时，该字体的展示大小就是 9px，该方案的好处是不会造成盒子的塌陷，盒子大小不会进行缩放，只会缩放字体。
