import{_ as t,p as a,q as n,a1 as e}from"./framework-5866ffd3.js";const o={},d=e(`<h1 id="正则表达式" tabindex="-1"><a class="header-anchor" href="#正则表达式" aria-hidden="true">#</a> 正则表达式</h1><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>正则表达式想必我们大多数人都使用过，或许我们使用的场景非常复杂，亦或许我们使用的场景相对简单，总归我们都是使用过正则表达式的。</p><h2 id="基本语法" tabindex="-1"><a class="header-anchor" href="#基本语法" aria-hidden="true">#</a> 基本语法</h2><h3 id="特殊字符" tabindex="-1"><a class="header-anchor" href="#特殊字符" aria-hidden="true">#</a> 特殊字符</h3><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>\\</td><td>依照下列规则匹配： 在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，前面没有 &quot;&quot; 的 &quot;b&quot; 通常匹配小写字母 &quot;b&quot;，即字符会被作为字面理解，无论它出现在哪里。但如果前面加了 &quot;&quot;，它将不再匹配任何字符，而是表示一个字符边界。 在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。详情请参阅下文中的 &quot;转义（Escaping）&quot; 部分。 如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。所以为了在模式中添加一个反斜杠，你需要在字符串字面量中转义它。/[a-z]\\s/i  和  new RegExp(&quot;[a-z]\\s&quot;, &quot;i&quot;)  创建了相同的正则表达式：一个用于搜索后面紧跟着空白字符（\\s  可看后文）并且在 a-z 范围内的任意字符的表达式。为了通过字符串字面量给 RegExp 构造函数创建包含反斜杠的表达式，你需要在字符串级别和正则表达式级别都对它进行转义。例如  /[a-z]:\\/i  和  new RegExp(&quot;[a-z]:\\\\&quot;,&quot;i&quot;)  会创建相同的表达式，即匹配类似 &quot;C:&quot; 字符串。</td></tr><tr><td>^</td><td>匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。 例如，/^A/  并不会匹配 &quot;an A&quot; 中的 &#39;A&#39;，但是会匹配 &quot;An E&quot; 中的 &#39;A&#39;。 当 &#39;^&#39; 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。反向字符集合   一节有详细介绍和示例。</td></tr><tr><td>$</td><td>匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置。 例如，/t$/  并不会匹配 &quot;eater&quot; 中的 &#39;t&#39;，但是会匹配 &quot;eat&quot; 中的 &#39;t&#39;。</td></tr><tr><td>*</td><td>匹配前一个表达式 0 次或多次。等价于  {0,}。 例如，/bo*/  会匹配 &quot;A ghost boooooed&quot; 中的 &#39;booooo&#39; 和 &quot;A bird warbled&quot; 中的 &#39;b&#39;，但是在 &quot;A goat grunted&quot; 中不会匹配任何内容。</td></tr><tr><td>+</td><td>匹配前面一个表达式 1 次或者多次。等价于  {1,}。 例如，/a+/  会匹配 &quot;candy&quot; 中的 &#39;a&#39; 和 &quot;caaaaaaandy&quot; 中所有的 &#39;a&#39;，但是在 &quot;cndy&quot; 中不会匹配任何内容。</td></tr><tr><td>?</td><td>匹配前面一个表达式 0 次或者 1 次。等价于  {0,1}。 例如，/e?le?/  匹配 &quot;angel&quot; 中的 &#39;el&#39;、&quot;angle&quot; 中的 &#39;le&#39; 以及 &quot;oslo&#39; 中的 &#39;l&#39;。 如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 &quot;123abc&quot; 使用  /\\d+/  将会匹配 &quot;123&quot;，而使用  /\\d+?/  则只会匹配到 &quot;1&quot;。 还用于先行断言中，如本表的  x(?=y)  和  x(?!y)  条目所述。</td></tr><tr><td>.</td><td>（小数点）默认匹配除换行符之外的任何单个字符。 例如，/.n/  将会匹配 &quot;nay, an apple is on the tree&quot; 中的 &#39;an&#39; 和 &#39;on&#39;，但是不会匹配 &#39;nay&#39;。 如果  s (&quot;dotAll&quot;) 标志位被设为 true，它也会匹配换行符。</td></tr><tr><td>(x)</td><td>像下面的例子展示的那样，它会匹配 &#39;x&#39; 并且记住匹配项。其中括号被称为捕获括号。 模式  /(foo) (bar) \\1 \\2/  中的 &#39;(foo)&#39; 和 &#39;(bar)&#39; 匹配并记住字符串 &quot;foo bar foo bar&quot; 中前两个单词。模式中的  \\1  和  \\2  表示第一个和第二个被捕获括号匹配的子字符串，即  foo  和  bar，匹配了原字符串中的后两个单词。注意  \\1、\\2、...、\\n  是用在正则表达式的匹配环节，详情可以参阅后文的  \\n  条目。而在正则表达式的替换环节，则要使用像  $1、$2、...、$n  这样的语法，例如，&#39;bar foo&#39;.replace(/(...) (...)/, &#39;$2 $1&#39;)。$&amp;  表示整个用于匹配的原字符串。</td></tr><tr><td>(?:x)</td><td>匹配 &#39;x&#39; 但是不记住匹配项。这种括号叫作非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式。看看这个例子  /(?:foo){1,2}/。如果表达式是  /foo{1,2}/，{1,2}  将只应用于 &#39;foo&#39; 的最后一个字符 &#39;o&#39;。如果使用非捕获括号，则  {1,2}  会应用于整个 &#39;foo&#39; 单词。更多信息，可以参阅下文的   使用括号的子字符串匹配   条目。</td></tr><tr><td><code>x(?=y)</code></td><td>匹配&#39;x&#39;仅仅当&#39;x&#39;后面跟着&#39;y&#39;.这种叫做先行断言。 例如，/Jack(?=Sprat)/会匹配到&#39;Jack&#39;仅当它后面跟着&#39;Sprat&#39;。/Jack(?=Sprat|Frost)/匹配‘Jack’仅当它后面跟着&#39;Sprat&#39;或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</td></tr><tr><td><code>(?&lt;=y)x</code></td><td>匹配&#39;x&#39;仅当&#39;x&#39;前面是&#39;y&#39;.这种叫做后行断言。 例如，/(?&lt;=Jack)Sprat/会匹配到&#39; Sprat &#39;仅仅当它前面是&#39; Jack &#39;。/(?&lt;=Jack|Tom)Sprat/匹配‘Sprat ’仅仅当它前面是&#39;Jack&#39;或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。</td></tr><tr><td><code>x(?!y)</code></td><td>仅仅当&#39;x&#39;后面不跟着&#39;y&#39;时匹配&#39;x&#39;，这被称为正向否定查找。 例如，仅仅当这个数字后面没有跟小数点的时候，/\\d+(?!.)/ 匹配一个数字。正则表达式/\\d+(?!.)/.exec(&quot;3.141&quot;) 匹配‘141’而不是‘3.141’</td></tr><tr><td><code>(?&lt;!y)x </code></td><td>仅仅当&#39;x&#39;前面不是&#39;y&#39;时匹配&#39;x&#39;，这被称为反向否定查找。 例如，仅仅当这个数字前面没有负号的时候，/(?&lt;!-)\\d+/  匹配一个数字。 /(?&lt;!-)\\d+/.exec(&#39;3&#39;)  匹配到 &quot;3&quot;. /(?&lt;!-)\\d+/.exec(&#39;-3&#39;)  因为这个数字前有负号，所以没有匹配到。</td></tr><tr><td>x|y</td><td>匹配‘x’或者‘y’。 例如，/green|red/匹配“green apple”中的‘green’和“red apple”中的‘red’</td></tr><tr><td>{n}</td><td>n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。 比如， /a{2}/ 不会匹配“candy”中的&#39;a&#39;,但是会匹配“caandy”中所有的 a，以及“caaandy”中的前两个&#39;a&#39;。</td></tr><tr><td>{n,}</td><td>n 是一个正整数，匹配前一个字符至少出现了 n 次。 例如，/a{2,}/ 匹配 &quot;aa&quot;, &quot;aaaa&quot; 和 &quot;aaaaa&quot; 但是不匹配 &quot;a&quot;。</td></tr><tr><td>{n,m}</td><td>n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次。如果 n 或者 m 的值是 0，这个值被忽略。 例如，/a{1, 3}/ 并不匹配“cndy”中的任意字符，匹配“candy”中的 a，匹配“caandy”中的前两个 a，也匹配“caaaaaaandy”中的前三个 a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的 a。</td></tr><tr><td>[xyz]</td><td>一个字符集合。匹配方括号中的任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。 例如，[abcd] 和 [a-d] 是一样的。他们都匹配&quot;brisket&quot;中的‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\\w.]+/与字符串“test.i.ng”匹配。</td></tr><tr><td>[^xyz]</td><td>一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。 例如，[^abc] 和 [^a-c] 是一样的。他们匹配&quot;brisket&quot;中的‘r’，也匹配“chop”中的‘h’。</td></tr><tr><td>[\\b]</td><td>匹配一个退格 (U+0008)。（不要和\\b 混淆了。）</td></tr><tr><td>\\b</td><td>匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是 0。（不要和 [\\b] 混淆了） 使用&quot;moon&quot;举例： /\\bm/匹配“moon”中的‘m’； /oo\\b/并不匹配&quot;moon&quot;中的&#39;oo&#39;，因为&#39;oo&#39;被一个“字”字符&#39;n&#39;紧跟着。 /oon\\b/匹配&quot;moon&quot;中的&#39;oon&#39;，因为&#39;oon&#39;是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。 /\\w\\b\\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。 备注： JavaScript 的正则表达式引擎将特定的字符集定义为“字”字符。不在该集合中的任何字符都被认为是一个断词。这组字符相当有限：它只包括大写和小写的罗马字母，十进制数字和下划线字符。不幸的是，重要的字符，例如“é”或“ü”，被视为断词。</td></tr><tr><td>\\B</td><td>匹配一个非单词边界。匹配如下几种情况： 字符串第一个字符为非“字”字符 字符串最后一个字符为非“字”字符 两个单词字符之间 两个非单词字符之间 空字符串 例如，/\\B../匹配&quot;noonday&quot;中的&#39;oo&#39;, 而/y\\B../匹配&quot;possibly yesterday&quot;中的’yes‘</td></tr><tr><td>\\cX</td><td>当 X 是处于 A 到 Z 之间的字符的时候，匹配字符串中的一个控制符。 例如，/\\cM/  匹配字符串中的 control-M (U+000D)。</td></tr><tr><td>\\d</td><td>匹配一个数字。等价于 [0-9]。 例如， /\\d/  或者  /[0-9]/  匹配&quot;B2 is the suite number.&quot;中的&#39;2&#39;。</td></tr><tr><td>\\D</td><td>匹配一个非数字字符。等价于 [^0-9]。 例如， /\\D/  或者  /[^0-9]/  匹配&quot;B2 is the suite number.&quot;中的&#39;B&#39; 。</td></tr><tr><td>\\f</td><td>匹配一个换页符 (U+000C)。</td></tr><tr><td>\\n</td><td>匹配一个换行符 (U+000A)。</td></tr><tr><td>\\r</td><td>匹配一个回车符 (U+000D)。</td></tr><tr><td>\\s</td><td>匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于  [\\f\\n\\r\\t\\v\\u0020\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。 例如，/\\s\\w*/  匹配&quot;foo bar.&quot;中的&#39; bar&#39;。 经测试，\\s 不匹配&quot;\\u180e&quot;，在当前版本 Chrome(v80.0.3987.122) 和 Firefox(76.0.1) 控制台输入/\\s/.test(&quot;\\u180e&quot;) 均返回 false。</td></tr><tr><td>\\S</td><td>匹配一个非空白字符。等价于  [^\\f\\n\\r\\t\\v\\u0020\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。 例如，/\\S\\w*/  匹配&quot;foo bar.&quot;中的&#39;foo&#39;。</td></tr><tr><td>\\t</td><td>匹配一个水平制表符 (U+0009)。</td></tr><tr><td>\\v</td><td>匹配一个垂直制表符 (U+000B)。</td></tr><tr><td>\\w</td><td>匹配一个单字字符（字母、数字或者下划线）。等价于  [A-Za-z0-9_]。 例如，/\\w/  匹配 &quot;apple,&quot; 中的 &#39;a&#39;，&quot;$5.28,&quot;中的 &#39;5&#39; 和 &quot;3D.&quot; 中的 &#39;3&#39;。</td></tr><tr><td>\\W</td><td>匹配一个非单字字符。等价于  [^A-Za-z0-9_]。 例如，/\\W/  或者  /[^A-Za-z0-9_]/  匹配 &quot;50%.&quot; 中的 &#39;%&#39;。</td></tr><tr><td>\\n</td><td>在正则表达式中，它返回最后的第 n 个子捕获匹配的子字符串 (捕获的数目以左括号计数)。 比如  /apple(,)\\sorange\\1/  匹配&quot;apple, orange, cherry, peach.&quot;中的&#39;apple, orange,&#39; 。</td></tr><tr><td>\\0</td><td>匹配 NULL（U+0000）字符，不要在这后面跟其他小数，因为  \\0&lt;digits&gt;  是一个八进制转义序列。</td></tr><tr><td>\\xhh</td><td>匹配一个两位十六进制数（\\x00-\\xFF）表示的字符。</td></tr><tr><td>\\uhhhh</td><td>匹配一个四位十六进制数表示的 UTF-16 代码单元。</td></tr><tr><td>\\u{hhhh}或\\u{hhhhh}</td><td>（仅当设置了 u 标志时）匹配一个十六进制数表示的 Unicode 字符。</td></tr></tbody></table><h3 id="模式" tabindex="-1"><a class="header-anchor" href="#模式" aria-hidden="true">#</a> 模式</h3><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>g</td><td>全局搜索。</td></tr><tr><td>i</td><td>不区分大小写搜索。</td></tr><tr><td>m</td><td>多行搜索。</td></tr><tr><td>s</td><td>允许 . 匹配换行符。</td></tr><tr><td>u</td><td>使用 unicode 码的模式进行匹配。</td></tr><tr><td>y</td><td>执行“粘性 (sticky)”搜索，匹配从目标字符串的当前位置开始。</td></tr></tbody></table><p>其中 <code>g</code> 与 <code>m</code> 的区别是，m 可以匹配多行，并将<code>^</code>与<code>$</code>分别作用于每一行上，其中<code>g</code>可以匹配多次，而<code>m</code>默认只能匹配首次，示例如下：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">abcdef
acccf
aafd
</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^a\\w+f$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// null</span>
foo<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^a\\w+f$</span><span class="token regex-delimiter">/</span><span class="token regex-flags">m</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// abcdef 只有m表示多行匹配，只会匹配到第一个就结束，其中的起始符与终止符均作用在每一行上</span>
foo<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^a\\w+f$</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gm</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// abcdef、acccf 使用m和g表示多行且多次匹配，起始符与终止符均作用在每一行上</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="捕获组" tabindex="-1"><a class="header-anchor" href="#捕获组" aria-hidden="true">#</a> 捕获组</h3><p>在我们的正则中可以使用小括号来标识捕获组，例如：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a(.*)d</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">&#39;abccccd&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [abcccd, bcccc]，第一个捕获组在数组的第二个索引位置</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>以此类推，第 n 个捕获组在索引的第 n+1 个位置上</p>`,14),s=[d];function r(u,c){return a(),n("div",null,s)}const l=t(o,[["render",r],["__file","index.html.vue"]]);export{l as default};
