import{_ as n,p as s,q as a,a1 as t}from"./framework-5866ffd3.js";const p={},e=t(`<h1 id="回溯法" tabindex="-1"><a class="header-anchor" href="#回溯法" aria-hidden="true">#</a> 回溯法</h1><ul><li><p>前言</p><ul><li>回溯是递归的副产品，也就是说只要有递归就一定存在回溯！</li><li>回溯法很多人一听这么高级的名字一定是什么高效算法吧？很遗憾，并不是这样的，回溯法的效率并不高，它是一种暴力枚举的方法。那我们为什么还要用回溯呢？因为在解决某些特定的问题时能暴力枚举已经很不错了，至少截止到目前还没有什么更高效的算法。</li></ul></li><li><p>回溯法的前世今生</p><ul><li><p>回溯法其实就是一棵树结构，我们一般使用递归来实现深度优先遍历。回溯法是有固定解题套路的，下面讲述下固定套路。</p></li><li><p>回溯法固定解题模板：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">template</span><span class="token punctuation">(</span>nums<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 收集结果的数组</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>收集结果的条件<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 这个位置进行一系列的结果处理一般如下：</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>要收集的内容<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      处理某些操作以达到收集条件<span class="token punctuation">;</span>
      <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      取消上述的某些操作以达到回溯的目的<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">backtracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>其中，我们上述模板代码中的 for 循环可以理解为树形结构的宽度，而我们的递归调用中可以理解为我们树的深度也就是一棵树我们在每一个分支上面寻找我们要求解的答案，直到找到所有的题解。</p></li></ul></li></ul>`,2),c=[e];function o(i,l){return s(),a("div",null,c)}const k=n(p,[["render",o],["__file","backtrack.html.vue"]]);export{k as default};
